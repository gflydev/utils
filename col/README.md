# col - Collection Utility Functions for Go

The `col` package provides a comprehensive set of utility functions for working with collections (slices and maps) in Go. It's inspired by libraries like Lodash for JavaScript and offers a wide range of functions to make working with collections easier and more expressive.

## Installation

```bash
go get github.com/gflydev/utils/col
```

## Usage

```go
import "github.com/gflydev/utils/col"
```

## Functions

### Collection Operations

#### CountBy

Counts elements in a collection based on a key generated by an iteratee function.

```go
result := col.CountBy([]int{1, 2, 3, 4}, func(n int) string {
    if n%2 == 0 {
        return "even"
    }
    return "odd"
})
// result: map[string]int{"odd": 2, "even": 2}

result := col.CountBy([]int{1, 3, 5}, func(n int) string {
    if n%2 == 0 {
        return "even"
    }
    return "odd"
})
// result: map[string]int{"odd": 3}
```

#### Every

Checks if all elements in a collection satisfy a predicate.

```go
result := col.Every([]int{2, 4, 6}, func(n int) bool { 
    return n%2 == 0 
})
// result: true

result := col.Every([]int{2, 3, 6}, func(n int) bool { 
    return n%2 == 0 
})
// result: false
```

#### Filter

Filters elements in a collection based on a predicate.

```go
result := col.Filter([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: []int{2, 4}

result := col.Filter([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: []int{}
```

#### Find

Returns the first element in a collection that satisfies a predicate.

```go
result, ok := col.Find([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: 2, ok: true

result, ok := col.Find([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: 0, ok: false
```

#### FindLast

Returns the last element in a collection that satisfies a predicate.

```go
result, ok := col.FindLast([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: 4, ok: true

result, ok := col.FindLast([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: 0, ok: false
```

#### Includes

Checks if a collection includes a specific value.

```go
result := col.Includes([]int{1, 2, 3, 4}, 3)
// result: true

result := col.Includes([]int{1, 2, 3, 4}, 5)
// result: false
```

#### Size

Returns the size of a collection.

Parameters:
- collection: The slice to measure

Returns:
- int: The number of elements in the collection

```go
result := col.Size([]int{1, 2, 3, 4})
// result: 4

result := col.Size([]int{})
// result: 0
```

#### Some

Checks if at least one element in a collection satisfies a predicate.

Parameters:
- collection: The slice to process
- predicate: The function that returns true for elements to check

Returns:
- bool: True if any element satisfies the predicate, false otherwise

```go
result := col.Some([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: true

result := col.Some([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: false
```

#### SortBy

Sorts a collection based on a key generated by an iteratee function.

Parameters:
- collection: The slice to process
- iteratee: The function that returns the value to sort by

Returns:
- []T: A new sorted slice

```go
result := col.SortBy([]int{4, 2, 1, 3}, func(n int) int { 
    return n 
})
// result: []int{1, 2, 3, 4}

type User struct {
    Name string
    Age  int
}

users := []User{
    {Name: "Alice", Age: 30},
    {Name: "Bob", Age: 25},
    {Name: "Charlie", Age: 35},
}

result := col.SortBy(users, func(u User) int { 
    return u.Age 
})
// result: []User{
//    {Name: "Bob", Age: 25},
//    {Name: "Alice", Age: 30},
//    {Name: "Charlie", Age: 35},
// }
```

#### Map

Transforms each element in a collection using an iteratee function.

Parameters:
- collection: The slice to process
- iteratee: The function to transform each element

Returns:
- []R: A new slice containing the transformed elements

```go
result := col.Map([]int{1, 2, 3, 4}, func(n int) int { 
    return n * 2 
})
// result: []int{2, 4, 6, 8}
```

#### Reject

Returns elements in a collection that don't satisfy a predicate.

Parameters:
- collection: The slice to process
- predicate: The function that returns true for elements to exclude

Returns:
- []T: A new slice containing only the elements that don't satisfy the predicate

```go
result := col.Reject([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: []int{1, 3}
```

#### Reduce

Reduces a collection to a single value by iteratively applying an iteratee function.

Parameters:
- collection: The slice to process
- iteratee: The function to apply to each element with the accumulator
- accumulator: The initial value of the accumulator

Returns:
- R: The final accumulated value

```go
result := col.Reduce([]int{1, 2, 3, 4}, func(acc int, n int) int { 
    return acc + n 
}, 0)
// result: 10
```

#### GroupBy

Groups elements in a collection based on a key generated by an iteratee function.

```go
result := col.GroupBy([]int{1, 2, 3, 4}, func(n int) string {
    if n%2 == 0 {
        return "even"
    }
    return "odd"
})
// result: map[string][]int{"odd": {1, 3}, "even": {2, 4}}
```

#### KeyBy

Creates an object composed of keys generated from the results of running each element of collection through iteratee.

Parameters:
- collection: The slice to process
- iteratee: The function to generate the key for each element

Returns:
- map[K]T: A map where keys are generated by the iteratee function and values are the original elements

```go
type User struct {
    ID   int
    Name string
}

users := []User{
    {ID: 1, Name: "Alice"},
    {ID: 2, Name: "Bob"},
}

result := col.KeyBy(users, func(u User) int { 
    return u.ID 
})
// result: map[int]User{
//    1: {ID: 1, Name: "Alice"},
//    2: {ID: 2, Name: "Bob"},
// }
```

#### Partition

Splits a collection into two groups: one with elements that satisfy a predicate and one with elements that don't.

Parameters:
- collection: The slice to process
- predicate: The function that returns true for elements to include in the first group

Returns:
- [][]T: A slice containing two slices: the first with elements that satisfy the predicate, the second with elements that don't satisfy the predicate

```go
result := col.Partition([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: [][]int{{2, 4}, {1, 3}}
```

#### ReduceRight

Reduces a collection to a value by iterating through the collection from right to left.

Parameters:
- collection: The slice to process
- iteratee: The function to apply to each element with the accumulator
- accumulator: The initial value of the accumulator

Returns:
- R: The final accumulated value

```go
result := col.ReduceRight([]int{1, 2, 3, 4}, func(acc int, n int) int { 
    return acc - n 
}, 0)
// result: -10
```

#### OrderBy

Sorts a collection based on a key generated by an iteratee function, with control over ascending or descending order.

```go
result := col.OrderBy([]int{4, 2, 1, 3}, func(n int) int { 
    return n 
}, true)
// result: []int{1, 2, 3, 4}

result := col.OrderBy([]int{4, 2, 1, 3}, func(n int) int { 
    return n 
}, false)
// result: []int{4, 3, 2, 1}
```

### Iteration Functions

#### ForEach

Iterates over elements in a collection and applies an iteratee function.

```go
sum := 0
col.ForEach([]int{1, 2, 3, 4}, func(n int) {
    sum += n
})
// sum: 10
```

#### MapWithIndex

Like Map, but the iteratee function also receives the index of the element.

Parameters:
- collection: The slice to process
- iteratee: The function to transform each element with its index

Returns:
- []R: A new slice containing the transformed elements

```go
result := col.MapWithIndex([]int{1, 2, 3, 4}, func(n int, i int) int { 
    return n * i 
})
// result: []int{0, 2, 6, 12}
```

#### ForEachWithIndex

Like ForEach, but the iteratee function also receives the index of the element.

```go
sum := 0
col.ForEachWithIndex([]int{1, 2, 3, 4}, func(n int, i int) {
    sum += n * i
})
// sum: 20
```

### Random Functions

#### Sample

Returns a random element from a collection.

Parameters:
- collection: The slice to process

Returns:
- T: A random element from the collection
- bool: True if an element was returned, false if the collection was empty

```go
result, ok := col.Sample([]int{1, 2, 3, 4})
// result: a random element from the collection, ok: true

result, ok := col.Sample([]int{})
// result: 0, ok: false
```

#### SampleSize

Returns n random elements from a collection.

Parameters:
- collection: The slice to process
- n: The number of random elements to return

Returns:
- []T: A slice containing n random elements from the collection

```go
result := col.SampleSize([]int{1, 2, 3, 4}, 2)
// result: 2 random elements from the collection

result := col.SampleSize([]int{1, 2, 3, 4}, 6)
// result: a shuffled version of the original collection
```

### Map Operations

#### ForEachMap

Iterates over elements in a map and applies an iteratee function.

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}
sum := 0
col.ForEachMap(m, func(v int, k string) {
    sum += v
})
// sum: 6
```

#### MapMap

Transforms each element in a map using an iteratee function.

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}
result := col.MapMap(m, func(v int, k string) string { 
    return k + string(rune('0' + v)) 
})
// result: []string{"a1", "b2", "c3"} (order may vary)
```

#### FilterMap

Filters elements in a map based on a predicate.

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}
result := col.FilterMap(m, func(v int, k string) bool { 
    return v%2 == 1 
})
// result: map[string]int{"a": 1, "c": 3}
```

#### ReduceMap

Reduces a map to a single value by iteratively applying an iteratee function.

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}
result := col.ReduceMap(m, func(acc string, v int, k string) string { 
    return acc + k 
}, "")
// result: "abc" (order may vary)
```

### Statistical Functions

#### Avg

Calculates the average of values in a collection.

```go
result := col.Avg([]int{1, 2, 3, 4}, func(n int) float64 { 
    return float64(n) 
})
// result: 2.5
```

### Array Manipulation

#### Chunk

Splits an array into chunks of the specified size.

```go
result := col.Chunk([]int{1, 2, 3, 4, 5}, 2)
// result: [][]int{{1, 2}, {3, 4}, {5}}
```

#### Contains

Checks if a collection contains a specific element.

```go
result := col.Contains([]int{1, 2, 3, 4}, 3)
// result: true

result := col.Contains([]int{1, 2, 3, 4}, 5)
// result: false
```

#### ContainsFn

Checks if a collection contains an element that satisfies the given predicate.

```go
result := col.ContainsFn([]int{1, 2, 3, 4}, func(n int) bool { 
    return n > 2 
})
// result: true

result := col.ContainsFn([]int{1, 2, 3, 4}, func(n int) bool { 
    return n > 5 
})
// result: false
```

#### Count

Returns the number of elements in a collection.

Parameters:
- collection: The slice to count

Returns:
- int: The number of elements in the collection

```go
result := col.Count([]int{1, 2, 3, 4})
// result: 4

result := col.Count([]int{})
// result: 0
```

#### Reverse

Reverses the order of the collection's items.

Parameters:
- collection: The slice to reverse

Returns:
- []T: A new slice with the elements in reverse order

```go
result := col.Reverse([]int{1, 2, 3, 4})
// result: []int{4, 3, 2, 1}
```

#### Slice

Returns a slice of the collection starting at the given index.

Parameters:
- collection: The slice to extract a portion from
- start: The starting index (can be negative to count from the end)

Returns:
- []T: A new slice containing elements from the start index to the end of the collection

```go
result := col.Slice([]int{1, 2, 3, 4}, 1)
// result: []int{2, 3, 4}

result := col.Slice([]int{1, 2, 3, 4}, -2)
// result: []int{3, 4}

result := col.Slice([]int{1, 2, 3, 4}, 5)
// result: []int{}
```

#### SliceWithLength

Returns a slice of the collection starting at the given index with the specified length.

Parameters:
- collection: The slice to extract a portion from
- start: The starting index (can be negative to count from the end)
- length: The number of elements to include in the result

Returns:
- []T: A new slice containing the specified number of elements from the start index

```go
result := col.SliceWithLength([]int{1, 2, 3, 4}, 1, 2)
// result: []int{2, 3}

result := col.SliceWithLength([]int{1, 2, 3, 4}, -2, 2)
// result: []int{3, 4}

result := col.SliceWithLength([]int{1, 2, 3, 4}, 0, 10)
// result: []int{1, 2, 3, 4}
```

#### Shuffle

Randomly shuffles the items in the collection.

Parameters:
- collection: The slice to shuffle

Returns:
- []T: A new slice with the elements in random order

```go
result := col.Shuffle([]int{1, 2, 3, 4})
// result: []int{2, 3, 1, 4} (random order)

result := col.Shuffle([]int{})
// result: []int{}
```

#### Collapse

Flattens a collection of collections into a single collection.

```go
result := col.Collapse([][]int{{1, 2}, {3, 4}})
// result: []int{1, 2, 3, 4}
```

#### CrossJoin

Creates a cartesian product of multiple collections.

```go
result := col.CrossJoin([]int{1, 2}, []int{3, 4}, []int{5, 6})
// result: [][]int{{1, 3, 5}, {1, 3, 6}, {1, 4, 5}, {1, 4, 6}, {2, 3, 5}, {2, 3, 6}, {2, 4, 5}, {2, 4, 6}}
```

#### Diff

Returns the elements in the first collection that are not in the second collection.

```go
result := col.Diff([]int{1, 2, 3, 4}, []int{2, 4})
// result: []int{1, 3}
```

#### DiffAssoc

Returns the key-value pairs in the first map that are not in the second map.

```go
result := col.DiffAssoc(
    map[string]int{"a": 1, "b": 2, "c": 3},
    map[string]int{"b": 2, "c": 4, "d": 5},
)
// result: map[string]int{"a": 1, "c": 3}
```

#### DiffKeys

Returns the key-value pairs in the first map whose keys are not in the second map.

```go
result := col.DiffKeys(
    map[string]int{"a": 1, "b": 2, "c": 3},
    map[string]int{"b": 20, "d": 40},
)
// result: map[string]int{"a": 1, "c": 3}
```

#### Except

Returns a map without the specified keys.

```go
result := col.Except(
    map[string]int{"a": 1, "b": 2, "c": 3},
    []string{"a", "c"},
)
// result: map[string]int{"b": 2}
```

#### First

Returns the first element in a collection that satisfies a predicate.

```go
result, ok := col.First([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: 2, ok: true

result, ok := col.First([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: 0, ok: false
```

#### FirstOrDefault

Returns the first element in a collection or a default value if the collection is empty.

```go
result := col.FirstOrDefault([]int{1, 2, 3}, 0)
// result: 1

result := col.FirstOrDefault([]int{}, 0)
// result: 0
```

#### FlatMap

Maps each element in a collection and then flattens the result.

```go
result := col.FlatMap([]int{1, 2}, func(n int) []int { 
    return []int{n, n * 2} 
})
// result: []int{1, 2, 2, 4}
```

#### Flatten

Flattens a collection of collections into a single collection.

```go
result := col.Flatten([][]int{{1, 2}, {3, 4}})
// result: []int{1, 2, 3, 4}
```

#### Flip

Swaps the collection's keys with their corresponding values.

```go
result := col.Flip(map[string]int{"a": 1, "b": 2})
// result: map[int]string{1: "a", 2: "b"}
```

#### Forget

Removes items from the collection by their keys.

```go
result := col.Forget(
    map[string]int{"a": 1, "b": 2, "c": 3},
    "a", "c",
)
// result: map[string]int{"b": 2}
```

#### Get

Retrieves an item from the collection by its key.

```go
result := col.Get(
    map[string]int{"a": 1, "b": 2},
    "a",
    0,
)
// result: 1

result := col.Get(
    map[string]int{"a": 1, "b": 2},
    "c",
    0,
)
// result: 0
```

#### Has

Determines if a given key exists in the collection.

```go
result := col.Has(
    map[string]int{"a": 1, "b": 2},
    "a",
)
// result: true

result := col.Has(
    map[string]int{"a": 1, "b": 2},
    "c",
)
// result: false
```

#### Implode

Joins the items in a collection into a single string.

```go
result := col.Implode(
    []int{1, 2, 3},
    ", ",
    func(n int) string { return string(rune('0' + n)) },
)
// result: "1, 2, 3"
```

#### Intersect

Removes any values from the original collection that are not present in the given array or collection.

```go
result := col.Intersect([]int{1, 2, 3, 4}, []int{2, 4, 6})
// result: []int{2, 4}
```

#### IntersectByKeys

Returns a new map containing only the key-value pairs from collection where the key is in the keys slice.

```go
result := col.IntersectByKeys(
    map[string]int{"a": 1, "b": 2, "c": 3},
    []string{"a", "c"},
)
// result: map[string]int{"a": 1, "c": 3}
```

#### IsEmpty

Checks if a collection is empty.

```go
result := col.IsEmpty([]int{})
// result: true

result := col.IsEmpty([]int{1, 2, 3})
// result: false
```

#### IsNotEmpty

Checks if a collection is not empty.

```go
result := col.IsNotEmpty([]int{1, 2, 3})
// result: true

result := col.IsNotEmpty([]int{})
// result: false
```

#### Keys

Returns the keys of a map.

```go
result := col.Keys(map[string]int{"a": 1, "b": 2})
// result: []string{"a", "b"} (order may vary)
```

#### Last

Returns the last element in a collection that satisfies a predicate.

```go
result, ok := col.Last([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: 4, ok: true

result, ok := col.Last([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: 0, ok: false
```

#### LastOrDefault

Returns the last element in a collection or a default value if the collection is empty.

Parameters:
- collection: The slice to process
- defaultValue: The value to return if the collection is empty

Returns:
- T: The last element in the collection or the default value if the collection is empty

```go
result := col.LastOrDefault([]int{1, 2, 3}, 0)
// result: 3

result := col.LastOrDefault([]int{}, 0)
// result: 0
```

#### Max

Returns the maximum value in a collection.

Parameters:
- collection: The slice to process
- valueFunc: The function that extracts a numeric value from each element

Returns:
- V: The maximum value found, or zero if the collection is empty

```go
result := col.Max([]int{1, 2, 3, 4}, func(n int) int { 
    return n 
})
// result: 4

result := col.Max([]struct{Age int}{{Age: 25}, {Age: 30}, {Age: 20}}, func(p struct{Age int}) int { return p.Age })
// result: 30
```

#### Merge

Merges the given array or collection with the original collection.
If a key exists in both collections, the value from items will be used.

Parameters:
- collection: The base map to merge into
- items: The map to merge from

Returns:
- map[K]V: A new map containing all key-value pairs from both maps, with items taking precedence for duplicate keys

```go
result := col.Merge(
    map[string]int{"a": 1, "b": 2},
    map[string]int{"b": 3, "c": 4},
)
// result: map[string]int{"a": 1, "b": 3, "c": 4}
```

#### Min

Returns the minimum value in a collection.

Parameters:
- collection: The slice to process
- valueFunc: The function that extracts a numeric value from each element

Returns:
- V: The minimum value found, or zero if the collection is empty

```go
result := col.Min([]int{1, 2, 3, 4}, func(n int) int { 
    return n 
})
// result: 1

result := col.Min([]struct{Age int}{{Age: 25}, {Age: 30}, {Age: 20}}, func(p struct{Age int}) int { return p.Age })
// result: 20
```

#### Only

Returns the items in the collection with the specified keys.

Parameters:
- collection: The map to filter
- keys: The keys to keep in the result

Returns:
- map[K]V: A new map containing only the key-value pairs from collection where the key is in the keys slice

```go
result := col.Only(
    map[string]int{"a": 1, "b": 2, "c": 3},
    []string{"a", "c"},
)
// result: map[string]int{"a": 1, "c": 3}
```

#### Pad

Pads a collection to the specified size with a given value. If the size is less than or equal to the length of the collection, it returns the original collection.

**Parameters:**
- collection: The slice to pad
- size: The desired size of the resulting slice
- value: The value to use for padding

**Returns:**
- A new slice padded to the specified size with the given value, or the original slice if size is less than or equal to the length of the collection

```go
result := col.Pad([]int{1, 2, 3}, 5, 0)
// result: []int{1, 2, 3, 0, 0}

result := col.Pad([]int{1, 2, 3}, 2, 0)
// result: []int{1, 2, 3}
```

#### Pluck

Retrieves all of the values for a given key from each element in a collection.

**Parameters:**
- collection: The slice to process
- key: The function that extracts a value from each element

**Returns:**
- A new slice containing the values extracted from each element in the collection

```go
type User struct {
    Name string
    Age  int
}

users := []User{
    {Name: "Alice", Age: 30},
    {Name: "Bob", Age: 25},
}

result := col.Pluck(users, func(u User) string { 
    return u.Name 
})
// result: []string{"Alice", "Bob"}
```

#### Prepend

Adds items to the beginning of the collection.

**Parameters:**
- collection: The slice to prepend to
- values: The values to add to the beginning of the collection

**Returns:**
- A new slice with the values prepended to the collection

```go
result := col.Prepend([]int{3, 4}, 1, 2)
// result: []int{1, 2, 3, 4}
```

#### Pull

Removes and returns an item from the collection by key.

**Parameters:**
- collection: The slice to remove an item from
- index: The index of the item to remove

**Returns:**
- The removed item
- A new slice with the item removed

```go
element, result := col.Pull([]int{1, 2, 3, 4}, 1)
// element: 2, result: []int{1, 3, 4}
```

#### Push

Adds items to the end of the collection.

**Parameters:**
- collection: The slice to append to
- values: The values to add to the end of the collection

**Returns:**
- A new slice with the values appended to the collection

```go
result := col.Push([]int{1, 2}, 3, 4)
// result: []int{1, 2, 3, 4}
```

#### Put

Adds a key-value pair to a map.

Parameters:
- collection: The map to add the key-value pair to
- key: The key to set
- value: The value to set

Returns:
- map[K]V: A new map with the key-value pair added or updated

```go
result := col.Put(
    map[string]int{"a": 1, "b": 2},
    "c",
    3,
)
// result: map[string]int{"a": 1, "b": 2, "c": 3}
```

#### Random

Returns a random element from a collection.

Parameters:
- collection: The slice to get a random item from

Returns:
- T: A random item from the collection
- bool: True if an item was returned, false if the collection is empty

```go
result, ok := col.Random([]int{1, 2, 3, 4})
// result: a random element from the collection, ok: true

result, ok := col.Random([]int{})
// result: 0, ok: false
```

#### RandomOrDefault

Returns a random element from a collection or a default value if the collection is empty.

Parameters:
- collection: The slice to get a random element from
- defaultValue: The value to return if the collection is empty

Returns:
- T: A random element from the collection or the default value if the collection is empty

```go
result := col.RandomOrDefault([]int{1, 2, 3, 4}, 0)
// result: a random element from the collection

result := col.RandomOrDefault([]int{}, 0)
// result: 0
```

#### Search

Searches the collection for a given value and returns the corresponding index if successful.

Parameters:
- collection: The slice to search in
- value: The value to search for

Returns:
- int: The index of the found element, or -1 if not found
- bool: True if the element was found, false otherwise

```go
index, ok := col.Search([]int{1, 2, 3, 4}, 3)
// index: 2, ok: true

index, ok := col.Search([]int{1, 2, 3, 4}, 5)
// index: -1, ok: false
```

#### SearchFunc

Searches the collection using the given predicate function and returns the index of the first matching element.

Parameters:
- collection: The slice to search in
- predicate: The function that returns true for the element to find

Returns:
- int: The index of the first element that satisfies the predicate, or -1 if not found
- bool: True if an element was found, false otherwise

```go
index, ok := col.SearchFunc([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 && n > 2 
})
// index: 3, ok: true

index, ok := col.SearchFunc([]int{1, 2, 3, 4}, func(n int) bool { 
    return n > 4 
})
// index: -1, ok: false
```

#### Shift

Removes the first element from a collection and returns it.

Parameters:
- collection: The slice to remove the first element from

Returns:
- T: The first element of the collection, or zero value if the collection is empty
- []T: The remaining elements of the collection

```go
element, result := col.Shift([]int{1, 2, 3, 4})
// element: 1, result: []int{2, 3, 4}

element, result := col.Shift([]int{})
// element: 0, result: []int{}
```

#### Sort

Sorts a collection using a comparison function.

Parameters:
- collection: The slice to sort
- less: The comparison function that defines the sort order. Should return true if the first argument should be ordered before the second.

Returns:
- []T: A new sorted slice

```go
result := col.Sort([]int{4, 2, 1, 3}, func(a, b int) bool { 
    return a < b 
})
// result: []int{1, 2, 3, 4}

result := col.Sort([]int{3, 1, 4, 2}, func(a, b int) bool { 
    return a > b 
})
// result: []int{4, 3, 2, 1}
```

#### SortByDesc

Sorts a collection in descending order based on a key generated by an iteratee function.

Parameters:
- collection: The slice to process
- keyFunc: The function that returns the value to sort by
- less: The comparison function that defines the sort order. Should return true if the first argument should be ordered before the second.

Returns:
- []T: A new slice sorted in descending order by the extracted keys

```go
result := col.SortByDesc([]int{1, 2, 3, 4}, func(n int) int { 
    return n 
}, func(a, b int) bool { 
    return a < b 
})
// result: []int{4, 3, 2, 1}

// Sort strings in descending order
result := col.SortByDesc([]string{"a", "c", "b"}, func(s string) string { 
    return s 
}, func(a, b string) bool { 
    return a < b 
})
// result: []string{"c", "b", "a"}
```

#### Splice

Removes and returns a slice of elements from the collection starting at the given index.

Parameters:
- collection: The slice to modify
- start: The starting index (can be negative to count from the end)
- length: The number of elements to remove

Returns:
- []T: A slice containing the removed elements
- []T: The modified collection with elements removed

```go
removed, result := col.Splice([]int{1, 2, 3, 4}, 1, 2)
// removed: []int{2, 3}, result: []int{1, 4}

removed, result := col.Splice([]int{1, 2, 3}, -1, 1)
// removed: []int{3}, result: []int{1, 2}

removed, result := col.Splice([]int{1, 2, 3}, 5, 1)
// removed: []int{}, result: []int{1, 2, 3}
```

#### Split

Breaks a collection into the given number of groups.

Parameters:
- collection: The slice to split
- numberOfGroups: The number of groups to split the collection into

Returns:
- [][]T: A slice of slices, where each inner slice contains elements distributed evenly

```go
result := col.Split([]int{1, 2, 3, 4, 5, 6}, 3)
// result: [][]int{{1, 4}, {2, 5}, {3, 6}}

result := col.Split([]int{1, 2, 3, 4, 5}, 2)
// result: [][]int{{1, 3, 5}, {2, 4}}

result := col.Split([]int{}, 3)
// result: [][]int{}
```

#### Sum

Returns the sum of all items in the collection.

Parameters:
- collection: The slice to sum
- valueFunc: The function that extracts a numeric value from each element

Returns:
- V: The sum of all values extracted from the collection

```go
result := col.Sum([]int{1, 2, 3, 4}, func(n int) int { 
    return n 
})
// result: 10

result := col.Sum([]int{1, 2, 3}, func(n int) int { 
    return n * 2 
})
// result: 12

result := col.Sum([]struct{Value int}{{1}, {2}}, func(x struct{Value int}) int { 
    return x.Value 
})
// result: 3
```

#### Take

Takes the first n elements from a collection.

Parameters:
- collection: The slice to extract elements from
- limit: The number of elements to take from the beginning of the collection

Returns:
- []T: A new slice containing the first n elements, or the entire collection if n is greater than the collection length

```go
result := col.Take([]int{1, 2, 3, 4}, 2)
// result: []int{1, 2}

result := col.Take([]int{1, 2, 3}, 5)
// result: []int{1, 2, 3}

result := col.Take([]int{1, 2, 3}, 0)
// result: []int{}
```

#### Tap

Passes a collection to a callback and returns the collection. This is useful for performing side effects on a collection while maintaining a fluent interface.

Parameters:
- collection: The slice to pass to the callback
- callback: The function to call with the collection

Returns:
- []T: The original collection (which may be modified by the callback)

```go
sum := 0
result := col.Tap([]int{1, 2, 3, 4}, func(arr []int) {
    for _, n := range arr {
        sum += n
    }
})
// sum: 10, result: []int{1, 2, 3, 4}

nums := []int{1, 2}
result := col.Tap(nums, func(x []int) { 
    x[0] = 99 
})
// result: []int{99, 2}
```

#### Unique

Returns all of the unique items in the collection.

Parameters:
- collection: The slice to remove duplicates from

Returns:
- []T: A new slice containing only unique elements, preserving the original order of first occurrence

```go
result := col.Unique([]int{1, 2, 2, 3, 3, 3, 4})
// result: []int{1, 2, 3, 4}

result := col.Unique([]string{"a", "a", "b", "c"})
// result: []string{"a", "b", "c"}
```

#### UniqueBy

Returns all of the unique items in the collection using the given key function.

Parameters:
- collection: The slice to remove duplicates from
- keyFunc: The function that extracts the key to determine uniqueness

Returns:
- []T: A new slice containing only elements with unique keys, preserving the original order of first occurrence

```go
type User struct {
    ID   int
    Name string
}

users := []User{
    {ID: 1, Name: "Alice"},
    {ID: 2, Name: "Bob"},
    {ID: 1, Name: "Charlie"},
}

result := col.UniqueBy(users, func(u User) int { 
    return u.ID 
})
// result: []User{{ID: 1, Name: "Alice"}, {ID: 2, Name: "Bob"}}

result := col.UniqueBy([]int{1, 2, 3, 4, 5, 6}, func(n int) int { return n % 3 })
// Returns: []int{1, 2, 3} (because 1%3=1, 2%3=2, 3%3=0, 4%3=1, 5%3=2, 6%3=0)
```

#### Values

Returns the values of a map.

```go
result := col.Values(map[string]int{"a": 1, "b": 2})
// result: []int{1, 2} (order may vary)
```

#### Zip

Combines multiple collections into a collection of collections.

Parameters:
- collection: The base slice to merge with other arrays
- arrays: Variable number of slices to merge with the collection

Returns:
- [][]T: A new slice of slices where each inner slice contains elements from the same position across all input slices

```go
result := col.Zip([]int{1, 2}, []int{3, 4}, []int{5, 6})
// result: [][]int{{1, 3, 5}, {2, 4, 6}}

result := col.Zip([]string{"a", "b"}, []string{"c", "d"})
// result: [][]string{{"a", "c"}, {"b", "d"}}
```

#### Unless

Executes the given callback when the condition is false.

Parameters:
- condition: The boolean condition to check
- collection: The slice to pass to the callback if the condition is false
- callback: The function to call with the collection if the condition is false

Returns:
- []T: The result of the callback if the condition is false, otherwise the original collection

```go
result := col.Unless(false, []int{1, 2, 3}, func(arr []int) []int {
    return col.Map(arr, func(n int) int { return n * 2 })
})
// result: []int{2, 4, 6} (because condition is false)

result := col.Unless(true, []int{1, 2, 3}, func(arr []int) []int {
    return col.Map(arr, func(n int) int { return n * 2 })
})
// result: []int{1, 2, 3} (because condition is true)

result := col.Unless(false, []int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3, 4} (because condition is false)
```

#### UnlessEmpty

Executes the given callback when the collection is not empty.

Parameters:
- collection: The slice to check and pass to the callback if not empty
- callback: The function to call with the collection if it's not empty

Returns:
- []T: The result of the callback if the collection is not empty, otherwise the original collection

```go
result := col.UnlessEmpty([]int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3, 4} (because collection is not empty)

result := col.UnlessEmpty([]int{}, func(x []int) []int { 
    return append(x, 1) 
})
// result: []int{} (because collection is empty)
```

#### UnlessNotEmpty

Executes the given callback when the collection is empty.

Parameters:
- collection: The slice to check and pass to the callback if empty
- callback: The function to call with the collection if it's empty

Returns:
- []T: The result of the callback if the collection is empty, otherwise the original collection

```go
result := col.UnlessNotEmpty([]int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3} (because collection is not empty)

result := col.UnlessNotEmpty([]int{}, func(x []int) []int { 
    return append(x, 1) 
})
// result: []int{1} (because collection is empty)
```

#### Values

Returns all of the values in the map collection.

Parameters:
- collection: The map to extract values from

Returns:
- []V: A slice containing all values from the map

```go
result := col.Values(map[string]int{"a": 1, "b": 2, "c": 3})
// result: []int{1, 2, 3}

result := col.Values(map[string]int{})
// result: []int{}
```

#### When

Executes the given callback when the condition is true.

Parameters:
- condition: The boolean condition to check
- collection: The slice to pass to the callback if the condition is true
- callback: The function to call with the collection if the condition is true

Returns:
- []T: The result of the callback if the condition is true, otherwise the original collection

```go
result := col.When(true, []int{1, 2, 3}, func(arr []int) []int {
    return col.Map(arr, func(n int) int { return n * 2 })
})
// result: []int{2, 4, 6} (because condition is true)

result := col.When(false, []int{1, 2, 3}, func(arr []int) []int {
    return col.Map(arr, func(n int) int { return n * 2 })
})
// result: []int{1, 2, 3} (because condition is false)

result := col.When(true, []int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3, 4} (because condition is true)
```

#### WhenEmpty

Executes the given callback when the collection is empty.

Parameters:
- collection: The slice to check and pass to the callback if empty
- callback: The function to call with the collection if it's empty

Returns:
- []T: The result of the callback if the collection is empty, otherwise the original collection

```go
result := col.WhenEmpty([]int{}, func(x []int) []int { 
    return append(x, 1) 
})
// result: []int{1} (because collection is empty)

result := col.WhenEmpty([]int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3} (because collection is not empty)
```

#### WhenNotEmpty

Executes the given callback when the collection is not empty.

Parameters:
- collection: The slice to check and pass to the callback if not empty
- callback: The function to call with the collection if it's not empty

Returns:
- []T: The result of the callback if the collection is not empty, otherwise the original collection

```go
result := col.WhenNotEmpty([]int{1, 2, 3}, func(x []int) []int { 
    return append(x, 4) 
})
// result: []int{1, 2, 3, 4} (because collection is not empty)

result := col.WhenNotEmpty([]int{}, func(x []int) []int { 
    return append(x, 1) 
})
// result: []int{} (because collection is empty)
```

#### Where

Filters elements in a collection based on a predicate.

Parameters:
- collection: The slice to filter
- predicate: The function that determines whether an element should be included in the result

Returns:
- []T: A new slice containing only the elements that satisfy the predicate

```go
result := col.Where([]int{1, 2, 3, 4}, func(n int) bool { 
    return n%2 == 0 
})
// result: []int{2, 4}

result := col.Where([]int{1, 3, 5}, func(n int) bool { 
    return n%2 == 0 
})
// result: []int{}
```

#### WhereIn

Filters elements in a collection whose key is in a list of values.

Parameters:
- collection: The slice to filter
- keyFunc: The function that extracts the key to check against the values
- values: The slice of values to check against

Returns:
- []T: A new slice containing only the elements whose extracted keys are in the values slice

```go
type User struct {
    ID   int
    Name string
}

users := []User{
    {ID: 1, Name: "Alice"},
    {ID: 2, Name: "Bob"},
    {ID: 3, Name: "Charlie"},
}

result := col.WhereIn(users, func(u User) int { 
    return u.ID 
}, []int{1, 3})
// result: []User{{ID: 1, Name: "Alice"}, {ID: 3, Name: "Charlie"}}

result := col.WhereIn([]int{1, 2, 3, 4, 5}, func(n int) int { 
    return n % 3 
}, []int{0, 1})
// result: []int{1, 3, 4} (because 1%3=1, 3%3=0, 4%3=1, which are in [0,1])
```

#### WhereNotIn

Filters elements in a collection whose key is not in a list of values.

Parameters:
- collection: The slice to filter
- keyFunc: The function that extracts the key to check against the values
- values: The slice of values to check against

Returns:
- []T: A new slice containing only the elements whose extracted keys are not in the values slice

```go
type User struct {
    ID   int
    Name string
}

users := []User{
    {ID: 1, Name: "Alice"},
    {ID: 2, Name: "Bob"},
    {ID: 3, Name: "Charlie"},
}

result := col.WhereNotIn(users, func(u User) int { 
    return u.ID 
}, []int{1, 3})
// result: []User{{ID: 2, Name: "Bob"}}

result := col.WhereNotIn([]int{1, 2, 3, 4, 5}, func(n int) int { 
    return n % 3 
}, []int{0, 1})
// result: []int{2, 5} (because 2%3=2, 5%3=2, which are not in [0,1])
```

### Function Utilities

#### After

Creates a function that invokes the provided function once it's called n or more times.

```go
fn := col.After(3, func() string { 
    return "done" 
})
// First two calls return zero value
fn() // returns ""
fn() // returns ""
// Third call invokes the function
fn() // returns "done"
// Subsequent calls also invoke the function
fn() // returns "done"
```

#### Before

Creates a function that invokes the provided function at most n times.

```go
count := 0
fn := col.Before(3, func() int { 
    count++
    return count 
})
fn() // returns 1
fn() // returns 2
fn() // returns 3
// Subsequent calls return the last result
fn() // returns 3
fn() // returns 3
```

#### Curry

Creates a function that accepts arguments of the provided function and either invokes it (if enough arguments are provided) or returns a function that accepts the remaining arguments.

```go
add := func(a, b int) int { 
    return a + b 
}
addCurried := col.Curry(add, 2)
add1 := addCurried(1)
result := add1(2) // returns 3
```

#### Debounce

Creates a debounced function that delays invoking the provided function until after a specified duration has elapsed since the last time the debounced function was invoked.

```go
// This will only execute once, 100ms after the last call
fn := col.Debounce(func() {
    fmt.Println("Function executed")
}, 100*time.Millisecond)

// These rapid calls will be debounced
fn()
fn()
fn() // Only this last call will trigger the function after 100ms
```
