// Package obj provides utility functions for object/struct/map manipulation.
package obj

import (
	"reflect"
	"sort"
)

// Assign assigns properties of source objects to the destination object.
// It's similar to Object.assign() in JavaScript.
// Example: Assign(map[string]interface{}{"a": 1}, map[string]interface{}{"b": 2}) -> map[string]interface{}{"a": 1, "b": 2}
func Assign[K comparable, V any](dest map[K]V, sources ...map[K]V) map[K]V {
	result := make(map[K]V)

	// Copy destination first
	for k, v := range dest {
		result[k] = v
	}

	// Copy sources
	for _, source := range sources {
		for k, v := range source {
			result[k] = v
		}
	}

	return result
}

// Clone creates a shallow clone of an object.
// Example: Clone(map[string]interface{}{"a": 1, "b": 2}) -> map[string]interface{}{"a": 1, "b": 2}
func Clone[K comparable, V any](obj map[K]V) map[K]V {
	result := make(map[K]V, len(obj))
	for k, v := range obj {
		result[k] = v
	}
	return result
}

// Entry Entries returns an array of key-value pairs.
// Example: Entries(map[string]int{"a": 1, "b": 2}) -> []Entry[string, int]{{"a", 1}, {"b", 2}}
type Entry[K comparable, V any] struct {
	Key   K
	Value V
}

func Entries[K comparable, V any](obj map[K]V) []Entry[K, V] {
	result := make([]Entry[K, V], 0, len(obj))
	for k, v := range obj {
		result = append(result, Entry[K, V]{k, v})
	}
	return result
}

// FromEntries returns an object composed from key-value pairs.
// Example: FromEntries([]Entry[string, int]{{"a", 1}, {"b", 2}}) -> map[string]int{"a": 1, "b": 2}
func FromEntries[K comparable, V any](entries []Entry[K, V]) map[K]V {
	result := make(map[K]V, len(entries))
	for _, entry := range entries {
		result[entry.Key] = entry.Value
	}
	return result
}

// Get gets the value at path of object.
// Example: Get(map[string]interface{}{"a": map[string]interface{}{"b": 2}}, "a.b") -> 2
func Get[T any](obj interface{}, path string) (T, bool) {
	var zero T
	val := reflect.ValueOf(obj)

	// Handle nil
	if !val.IsValid() {
		return zero, false
	}

	// If path is empty, return the object itself if it's of type T
	if path == "" {
		if val.Type().ConvertibleTo(reflect.TypeOf(zero)) {
			return val.Convert(reflect.TypeOf(zero)).Interface().(T), true
		}
		return zero, false
	}

	// TODO: Implement path traversal
	// This is a complex operation that requires parsing the path and traversing the object
	// For now, we'll just return a zero value and false

	return zero, false
}

// Has checks if path is a direct property of object.
// Example: Has(map[string]interface{}{"a": 1, "b": 2}, "a") -> true
func Has[K comparable, V any](obj map[K]V, key K) bool {
	_, ok := obj[key]
	return ok
}

// Keys returns an array of object's own enumerable property names.
// Example: Keys(map[string]interface{}{"a": 1, "b": 2}) -> []string{"a", "b"}
func Keys[K comparable, V any](obj map[K]V) []K {
	result := make([]K, 0, len(obj))
	for k := range obj {
		result = append(result, k)
	}
	return result
}

// KeysSorted returns a sorted array of object's own enumerable property names.
// Example: KeysSorted(map[string]interface{}{"b": 2, "a": 1}) -> []string{"a", "b"}
func KeysSorted[K comparable, V any](obj map[K]V) []K {
	keys := Keys(obj)

	// Sort the keys if they are of a sortable type
	if len(keys) > 0 {
		// Check if K is a type that can be sorted
		switch any(keys[0]).(type) {
		case string, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:
			sort.Slice(keys, func(i, j int) bool {
				// This is a bit of a hack, but it works for the basic types
				return reflect.ValueOf(keys[i]).String() < reflect.ValueOf(keys[j]).String()
			})
		}
	}

	return keys
}

// MapValues creates an object with the same keys as object and values generated by running each property through iteratee.
// Example: MapValues(map[string]int{"a": 1, "b": 2}, func(v int) int { return v * 2 }) -> map[string]int{"a": 2, "b": 4}
func MapValues[K comparable, V any, R any](obj map[K]V, iteratee func(V) R) map[K]R {
	result := make(map[K]R, len(obj))
	for k, v := range obj {
		result[k] = iteratee(v)
	}
	return result
}

// MapKeys creates an object with keys generated by running the property names of object through iteratee.
// Example: MapKeys(map[string]int{"a": 1, "b": 2}, func(k string) string { return k + "x" }) -> map[string]int{"ax": 1, "bx": 2}
func MapKeys[K comparable, V any, R comparable](obj map[K]V, iteratee func(K) R) map[R]V {
	result := make(map[R]V, len(obj))
	for k, v := range obj {
		result[iteratee(k)] = v
	}
	return result
}

// Merge merges properties of source objects into the destination object.
// Note: This is a simplified version that doesn't do deep merging due to Go's type system limitations.
// Example: Merge(map[string]interface{}{"a": 1}, map[string]interface{}{"b": 2}) -> map[string]interface{}{"a": 1, "b": 2}
func Merge[K comparable, V any](dest map[K]V, sources ...map[K]V) map[K]V {
	result := Clone(dest)

	for _, source := range sources {
		for k, v := range source {
			result[k] = v
		}
	}

	return result
}

// Omit creates an object composed of the object properties not included in the keys.
// Example: Omit(map[string]int{"a": 1, "b": 2, "c": 3}, "a", "c") -> map[string]int{"b": 2}
func Omit[K comparable, V any](obj map[K]V, keys ...K) map[K]V {
	result := make(map[K]V)

	// Create a set of keys to omit
	omitSet := make(map[K]bool)
	for _, k := range keys {
		omitSet[k] = true
	}

	// Copy all properties except those in the omit set
	for k, v := range obj {
		if !omitSet[k] {
			result[k] = v
		}
	}

	return result
}

// OmitBy creates an object composed of the object properties for which predicate returns falsey.
// Example: OmitBy(map[string]int{"a": 1, "b": 2, "c": 3}, func(v int) bool { return v > 2 }) -> map[string]int{"a": 1, "b": 2}
func OmitBy[K comparable, V any](obj map[K]V, predicate func(V) bool) map[K]V {
	result := make(map[K]V)

	for k, v := range obj {
		if !predicate(v) {
			result[k] = v
		}
	}

	return result
}

// Pick creates an object composed of the picked object properties.
// Example: Pick(map[string]int{"a": 1, "b": 2, "c": 3}, "a", "c") -> map[string]int{"a": 1, "c": 3}
func Pick[K comparable, V any](obj map[K]V, keys ...K) map[K]V {
	result := make(map[K]V)

	for _, k := range keys {
		if v, ok := obj[k]; ok {
			result[k] = v
		}
	}

	return result
}

// PickBy creates an object composed of the object properties for which predicate returns truthy.
// Example: PickBy(map[string]int{"a": 1, "b": 2, "c": 3}, func(v int) bool { return v > 2 }) -> map[string]int{"c": 3}
func PickBy[K comparable, V any](obj map[K]V, predicate func(V) bool) map[K]V {
	result := make(map[K]V)

	for k, v := range obj {
		if predicate(v) {
			result[k] = v
		}
	}

	return result
}

// Values returns an array of object's own enumerable property values.
// Example: Values(map[string]int{"a": 1, "b": 2}) -> []int{1, 2}
func Values[K comparable, V any](obj map[K]V) []V {
	result := make([]V, 0, len(obj))
	for _, v := range obj {
		result = append(result, v)
	}
	return result
}

// ValuesSorted returns a sorted array of object's own enumerable property values.
// Example: ValuesSorted(map[string]int{"b": 2, "a": 1}) -> []int{1, 2}
func ValuesSorted[K comparable, V any](obj map[K]V) []V {
	values := Values(obj)

	// Sort the values if they are of a sortable type
	if len(values) > 0 {
		// Check if V is a type that can be sorted
		switch any(values[0]).(type) {
		case string, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64:
			sort.Slice(values, func(i, j int) bool {
				// This is a bit of a hack, but it works for the basic types
				return reflect.ValueOf(values[i]).String() < reflect.ValueOf(values[j]).String()
			})
		}
	}

	return values
}

// Size returns the number of own enumerable properties of an object.
// Example: Size(map[string]int{"a": 1, "b": 2}) -> 2
func Size[K comparable, V any](obj map[K]V) int {
	return len(obj)
}

// IsEmpty checks if an object is empty.
// Example: IsEmpty(map[string]int{}) -> true
func IsEmpty[K comparable, V any](obj map[K]V) bool {
	return len(obj) == 0
}

// IsEqual performs a deep comparison between two objects to determine if they are equivalent.
// Example: IsEqual(map[string]int{"a": 1}, map[string]int{"a": 1}) -> true
func IsEqual[K comparable, V comparable](obj1, obj2 map[K]V) bool {
	if len(obj1) != len(obj2) {
		return false
	}

	for k, v1 := range obj1 {
		if v2, ok := obj2[k]; !ok || v1 != v2 {
			return false
		}
	}

	return true
}
